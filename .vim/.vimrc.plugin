"
" coding
"
" NeoCompate {{{
let g:acp_enableAtStartup = 0
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default'    : '',
    \ 'vimshell'   : $HOME.'/.vimshell_hist',
    \ 'scheme'     : $HOME.'/.gosh_completions',
    \ 'javascript' : join([$HOME.'/./dict/javascript.dict',$HOME.'/./dict/nodejs.dict'],','),
    \ 'coffee'     : join([$HOME.'/./dict/nodejs.dict',$HOME.'/./dict/javascript.dict'],',')
\ }
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

let g:neocomplete#enable_auto_select = 0
let g:neocomplete#disable_auto_complete = 0

inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" }}}
" NeoSnippet {{{
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

let g:neosnippet#enable_snipmate_compatibility = 1
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets,~/.vim/snippets'
" }}}
" git {{{

nnoremap <Leader>gd :<C-u>Gdiff<CR>
nnoremap <silent> <Leader>gs :<C-u>Gstatus<CR>
nnoremap <Leader>gl :<C-u>Glog<CR>
nnoremap <Leader>ga :<C-u>Gwrite<CR>
nnoremap <Leader>gr :<C-u>Gread<CR>
nnoremap <Leader>gc :<C-u>Gcommit<CR>
nnoremap <Leader>gC :<C-u>Git commit --amend<CR>
nnoremap <Leader>gp :<C-u>Git push<CR>
nnoremap <Leader>gb :<C-u>Gblame<CR>
nnoremap <Leader>gm :<C-u>Merginal<CR>
" }}}
" gist-vim {{{
let g:gist_open_browser_after_post = 1
let g:gist_detect_filetype = 1
" }}}
" surround.vim {{{


let g:surround_custom_mapping = {}
let g:surround_custom_mapping._ = {
      \ 'p':  "<pre> \r </pre>",
      \ 'w':  "%w(\r)",
      \ }
let g:surround_custom_mapping.help = {
      \ 'p':  "> \r <",
      \ }
let g:surround_custom_mapping.ruby = {
      \ '-':  "<% \r %>",
      \ '=':  "<%= \r %>",
      \ '9':  "(\r)",
      \ '5':  "%(\r)",
      \ '%':  "%(\r)",
      \ 'w':  "%w(\r)",
      \ '#':  "#{\r}",
      \ '3':  "#{\r}",
      \ 'e':  "begin \r end",
      \ 'E':  "<<EOS \r EOS",
      \ 'i':  "if \1if\1 \r end",
      \ 'u':  "unless \1unless\1 \r end",
      \ 'c':  "class \1class\1 \r end",
      \ 'm':  "module \1module\1 \r end",
      \ 'd':  "def \1def\1\2args\r..*\r(&)\2 \r end",
      \ 'p':  "\1method\1 do \2args\r..*\r|&| \2\r end",
      \ 'P':  "\1method\1 {\2args\r..*\r|&|\2 \r }",
      \ }
let g:surround_custom_mapping.javascript = {
      \ 'f':  "function(){ \r }"
      \ }
let g:surround_custom_mapping.lua = {
      \ 'f':  "function(){ \r }"
      \ }
let g:surround_custom_mapping.python = {
      \ 'p':  "print( \r)",
      \ '[':  "[\r]",
      \ }
" }}}
" easymotion {{{

" ホームポジションに近いキーを使う
let g:EasyMotion_keys='hjklasdfgyuiopqwertnmzxcvbHJKLASDFGYUIOPQWERTNMZXCVB'
let g:EasyMotion_leader_key=";"
" 1 ストローク選択を優先する
let g:EasyMotion_grouping=1
" カラー設定変更
hi EasyMotionTarget ctermbg=none ctermfg=red
hi EasyMotionShade  ctermbg=none ctermfg=blue


" vim-blowserreload-mac

nnoremap <Leader>rl :FirefoxReload<CR>
nnoremap <F5> :FirefoxReload<CR>
let g:returnApp = "MacVim"
" }}}
" smooth-scroll {{{

" let g:ac_smooth_scroll_no_default_key_mappings = 1
" nmap <silent> <space>d <Plug>(ac-smooth-scroll-c-d)
" nmap <silent> <space>u <Plug>(ac-smooth-scroll-c-u) " nmap <silent> <Space>k <Plug>(ac-smooth-scroll-c-b)
" let g:ac_smooth_scroll_du_sleep_time_msec = 40
" }}}
" Align.vim {{{

let g:Align_xstrlen=3
" }}}
" indentLine {{{
let g:indentLine_char = '┊'
let g:indentLine_fileTypeExclude = ['help', 'nerdtree', 'calendar', 'thumbnail', 'tweetvim']
nmap <silent><Leader>it :IndentLinesToggle<CR>
" }}}
" clever-f.vim {{{
let g:clever_f_ignore_case = 1
let g:clever_f_use_migemo = 1
let g:clever_f_not_overwrites_standard_mappings = 1
map f <Plug>(clever-f-f)
map F <Plug>(clever-f-F)
" }}}
" choosewin {{{
map  t  <Plug>(choosewin)
let g:choosewin_statusline_replace = 0
let g:choosewin_overlay_enable = 1
let g:choosewin_overlay_clear_multibyte = 1
let g:choosewin_blink_on_land = 0
let g:choosewin_label = "fgtrdsa"
let g:choosewin_tablabel = "123456789"
let g:choosewin_keymap   = {
      \'k' : 'tab_prev',
      \'j' : 'tab_next',
      \'h' : 'tab_first',
      \'l' : 'tab_last',
      \'<Space>' : 'win_land',
      \'t' : 'win_land',
      \}
" }}}
" gundo {{{
nnoremap U :<C-u>GundoToggle<CR>
"}}}
" vim-tags {{{

nnoremap <C-]> g<C-]> 
" }}}
" yankround.vim {{{

nmap p <Plug>(yankround-p)
nmap P <Plug>(yankround-P)
nmap <C-p> <Plug>(yankround-prev)
nmap <C-n> <Plug>(yankround-next)
"" 履歴取得数
let g:yankround_max_history = 50
""履歴一覧(kien/ctrlp.)
nnoremap <silent>g<C-p> :<C-u>CtrlPYankRound<CR>
" }}}
" sudmode.vim {{{
call submode#enter_with('expand-region', 'nv', 'r', '<Leader>e', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', 'e', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', 's', '<Plug>(expand_region_shrink)')

call submode#enter_with('winsize', 'n', '.', '<C-w>.', '<C-w><')
call submode#enter_with('winsize', 'n', ',', '<C-w>,', '<C-w>>')
call submode#enter_with('winsize', 'n', '=', '<C-w>=', '<C-w>+')
call submode#enter_with('winsize', 'n', '-', '<C-w>-', '<C-w>-')
call submode#map('winsize', 'n', '', '.', '<C-w><')
call submode#map('winsize', 'n', '', ',', '<C-w>>')
call submode#map('winsize', 'n', '', '=', '<C-w>+')
call submode#map('winsize', 'n', '', '-', '<C-w>-')

call submode#enter_with('changetab', 'n', '', 'gt', 'gt')
call submode#enter_with('changetab', 'n', '', 'gT', 'gT')
call submode#map('changetab', 'n', '', 't', 'gt')
call submode#map('changetab', 'n', '', 'T', 'gT')
  
"}}}
" vim-expand-region {{{
let g:expand_region_text_objects = {
  \ 'iw'  :0,
  \ 'iW'  :0,
  \ 'i"'  :0,
  \ 'i''' :0,
  \ 'i]'  :1,
  \ 'ib'  :1,
  \ 'iB'  :1,
  \ 'il'  :0,
  \ 'ip'  :0,
  \ 'ie'  :0,
  \ }

" }}}
" switch.vim {{{
noremap ! :Switch<CR>
" }}}
" smartinput {{{
if neobundle#tap('vim-smartinput')
  call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1
        \   }
        \ })

  function! neobundle#tapped.hooks.on_post_source(bundle)
    call smartinput_endwise#define_default_rules()
  endfunction

  call neobundle#untap()
endif

if neobundle#tap('vim-smartinput-endwise')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    " neosnippet and neocomplete compatible
    call smartinput#map_to_trigger('i', '<Plug>(vimrc_cr)', '<Enter>', '<Enter>')
    imap <expr><CR> !pumvisible() ? "\<Plug>(vimrc_cr)" :
          \ neosnippet#expandable() ? "\<Plug>(neosnippet_expand)" :
          \ neocomplete#close_popup()
  endfunction
  call neobundle#untap()
endif

" classとかの定義時に:までを入れる
call smartinput#define_rule({
\   'at'       : '^\s*\%(\<def\>\|\<if\>\|\<for\>\|\<while\>\|\<class\>\|\<with\>\)\s*\w\+.*\%#',
\   'char'     : '(',
\   'input'    : '():<Left><Left>',
\   'filetype' : ['python'],
\   })
" が、すでに:がある場合は重複させない. (smartinputでは、atの定義が長いほど適用の優先度が高くなる)
call smartinput#define_rule({
\   'at'       : '^\s*\%(\<def\>\|\<if\>\|\<for\>\|\<while\>\|\<class\>\|\<with\>\)\s*\w\+.*\%#.*:',
\   'char'     : '(',
\   'input'    : '()<Left>',
\   'filetype' : ['python'],
\   })
" 末尾:の手前でも、エンターとか:で次の行にカーソルを移動させる
call smartinput#define_rule({
\   'at'       : '^\s*\%(\<def\>\|\<if\>\|\<for\>\|\<while\>\|\<class\>\|\<with\>\)\s*\w\+.*\%#:$',
\   'char'     : ':',
\   'input'    : '<Right><CR>',
\   'filetype' : ['python'],
\   })
call smartinput#define_rule({
\   'at'       : '^\s*\%(\<def\>\|\<if\>\|\<for\>\|\<while\>\|\<class\>\|\<with\>\)\s*\w\+.*\%#:$',
\   'char'     : '<CR>',
\   'input'    : '<Right><CR>',
\   'filetype' : ['python'],
\   })
" }}}
"
" file
"
" Unite.vim {{{
" source  {{{
nnoremap    [unite]   <Nop>
nmap    s [unite]

nnoremap [unite]u  :<C-u>Unite -no-split<Space>
" 全部乗せ
nnoremap <silent> [unite]f  :<C-u>Unite -no-split -buffer-name=files file file/new<CR>
" ファイル一覧
nnoremap <silent> [unite]F  :<C-u>Unite -no-split -buffer-name=files file file/new<CR>
" バッファ一覧
nnoremap <silent> [unite]b  :<C-u>Unite -no-split buffer<CR>
" ブックマーク
nnoremap <silent> [unite]l  :<C-u>Unite -no-split bookmark<CR>
" 最近使用したファイル一覧
nnoremap <silent> [unite]m  :<C-u>Unite -no-split file_mru<CR>
" 現在のバッファのカレントディレクトリからファイル一覧
nnoremap <silent> [unite]d  :<C-u>UniteWithBufferDir -no-split file file/new<CR>
" project
nnoremap <silent> [unite]p  :<C-u>UniteWithProjectDir -no-split file file/new<CR>
" snippet一覧
nnoremap <silent> [unite]s  :<C-u>Unite neosnippet<CR>
" filetype一覧
nnoremap <silent> [unite]`  :<C-u>Unite filetype<CR>
"履歴を表示
nnoremap <silent> [unite]y  :<C-u>Unite yankround<CR>
"QuickRunの設定
nnoremap <silent> [unite]q  :<C-u>Unite quickrun_config<CR>
"tags
nnoremap <silent> [unite]t  :<C-u>Unite tags<CR>
"マッピングを表示
nnoremap <silent> [unite]h  :<C-u>Unite -no-split output:map<CR>
"grep
nnoremap <silent> [unite]G :<C-u>Unite -no-quit grep<CR>
"Codic
nnoremap <silent> [unite]c :<C-u>Unite -no-split codic<CR>
"git
nnoremap <silent> [unite]gb :<C-u>Unite -no-split giti/branch<CR>
nnoremap <silent> [unite]gc :<C-u>Unite -no-split giti/config<CR>
nnoremap <silent> [unite]gl :<C-u>Unite -no-split giti/log<CR>
nnoremap <silent> [unite]gr :<C-u>Unite -no-split giti/remote<CR>
nnoremap <silent> [unite]gs :<C-u>Unite -no-split giti/status<CR>
"search
nnoremap <silent> [unite]/ :<C-u>Unite -buffer-name=search line:all -start-insert<CR>
nnoremap <silent> / :<C-u>Unite -buffer-name=search line:all -start-insert<CR>
nnoremap ? /\v

nnoremap <silent> [unite]rc :<C-u>Unite file file/new -input=app/controllers/ <CR>
nnoremap <silent> [unite]rm :<C-u>Unite file file/new -input=app/models/ <CR>
nnoremap <silent> [unite]rv :<C-u>Unite file file/new -input=app/views/ <CR>
nnoremap <silent> [unite]rs :<C-u>Unite file file/new -input=app/assets/stylesheets/ <CR>
nnoremap <silent> [unite]rj :<C-u>Unite file file/new -input=app/assets/javascripts/ <CR>
nnoremap <silent> [unite]ro :<C-u>Unite file file/new -input=config/ <CR>
nnoremap <silent> [unite]rl :<C-u>Unite file file/new -input=lib/ <CR>
nnoremap <silent> [unite]rt :<C-u>Unite file file/new -input=spec/ <CR>
nnoremap <silent> [unite]rh :<C-u>Unite rails/heroku<CR>
nnoremap <silent> [unite]rr :<C-u>Unite rake<CR>
nnoremap <silent> [unite]rG :e Gemfile<CR>
nnoremap <silent> [unite]rR :e config/routes.rb<CR>
nnoremap <silent> [unite]rS :e db/seeds.rb<CR>
" }}}
" unite-grepのバックエンドをagに切り替える {{{
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '--nocolor --nogroup'
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_grep_max_candidates = 200
" }}}
" insert modeで開始
let g:unite_enable_start_insert = 1
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
let g:unite_source_history_yank_enable = 1
let g:yankring_zap_keys = ""

let g:vimfiler_sendto = {
\  'zip' : 'zip -r %F.zip %*',
\  'unzip' : 'unzip %f',
\  'firefox' : 'firefox %f',
\  'chrome' : 'open -a Google\ Chrome.app %f',
\  'finder' : 'open .'
\ }

" tabvsplit {{{
let s:unite_action = {
\   'is_selectable': 1,
\ }

function! s:unite_action.func(candidates)  " {{{
  tabnew `=a:candidates[0].action__path`
  for c in a:candidates[1 :]
    vsplit `=c.action__path`
  endfor
endfunction  " }}}

call unite#custom_action('openable', 'tabvsplit', s:unite_action)
unlet! s:unite_action
" }}}

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
  let g:unite_enable_start_insert = 1
  nmap <buffer> <ESC>      <Plug>(unite_exit)
  nmap <buffer> <ESC><ESC> <Plug>(unite_exit)
  nmap <buffer> q <Plug>(unite_exit)
  imap <buffer> jj      <Plug>(unite_insert_leave)
  nnoremap <silent><buffer> <C-k> :<C-u>call unite#mappings#do_action('preview')<CR>
  imap <buffer> <C-h>     <Plug>(unite_delete_backward_path)

  " ウィンドウを分割して開く
  nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('split')
  inoremap <silent> <buffer> <expr> <C-l> unite#do_action('split')

  " ウィンドウを縦に分割して開く
  nnoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
  inoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')

  " vimfilerで開く
  nnoremap <silent> <buffer> <expr> <C-f> unite#do_action('vimfiler')
  inoremap <silent> <buffer> <expr> <C-f> unite#do_action('vimfiler')
  " vimshellで開く
  nnoremap <silent> <buffer> <expr> <C-g> unite#do_action('vimshell')
  inoremap <silent> <buffer> <expr> <C-g> unite#do_action('vimshell')
endfunction

let g:unite_source_file_mru_limit = 200

function! UniteRefDoc()
    if &filetype =~ 'perl'
        Unite ref/perldoc
    elseif &filetype =~ 'php'
        Unite ref/phpmanual
    elseif &filetype =~ 'javascirpt'
        Unite ref/javascript ref/jquery
    elseif &filetype =~ 'coffee'
        Unite ref/javascript ref/jquery
    elseif &filetype =~ 'ruby'
        Unite ref/ri
    endif
endfunction
nnoremap <silent> [unite]K :<C-u>call UniteRefDoc()<CR> 
" }}}
" VimFiler {{{
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_external_copy_directory_command = 'cp -r $src $dest'
let g:vimfiler_external_copy_file_command = 'cp $src $dest'
let g:vimfiler_external_delete_command = 'rm -r $srcs'
let g:vimfiler_external_move_command = 'mv $srcs $dest'
" let g:vimfiler_edit_action = 'tabopen'
" Enable file operation commands.
let g:vimfiler_safe_mode_by_default = 0

command! -nargs=? -complete=file VimFilerTree call s:vimfiler_tree_launch(<f-args>)

  let s:org_scrolloff=-1
  function! s:noscrolloff_leftmouse()
    if s:org_scrolloff < 0
      let s:org_scrolloff = &scrolloff
    endif
    let &scrolloff = 0
    exe 'normal!' "\<LeftMouse>"
    " let &scrolloff = org_scrolloff
  endfunction
  function! s:restore_noscrolloff()
    if s:org_scrolloff < 0
      return
    endif
    let &scrolloff = s:org_scrolloff
    let s:org_scrolloff = -1
  endfunction
  autocmd CursorMoved * call s:restore_noscrolloff()

function! s:vimfiler_tree_launch(...)
  let fpath = a:0 > 0 ? a:1 : getcwd()
  execute 'VimFiler -toggle -split -direction=topleft -buffer-name=ftree -simple -winwidth=40 file:' . fpath
endfunction

function! s:vimfiler_smart_tree_h()
  let file = vimfiler#get_file()
  let cmd = "\<Plug>(vimfiler_smart_h)"
  if !empty(file)
    if file.vimfiler__is_opened
      let cmd = "\<Plug>(vimfiler_expand_tree)"
    elseif file.vimfiler__nest_level > 0
      let nest_level = file.vimfiler__nest_level
      while 1
        exe 'normal!' 'k'
        let file = vimfiler#get_file()
        if empty(file) || file.vimfiler__nest_level < nest_level
          " let cmd = "\<Plug>(vimfiler_expand_tree)" | break
          normal! ^
          return
        endif
      endwhile
    endif
  endif
  exe 'normal' cmd
  normal! ^
endfunction

function! s:vimfiler_tree_edit(method)
  " let file = vimfiler#get_file()
  " if empty(file) || empty(a:method) | return | endif
  " let path = file.action__path
  " wincmd p
  " execute a:method
  " exe 'edit' path
  if empty(a:method) | return | endif
  let linenr = line('.')
  let context = s:vimfiler_create_action_context(a:method, linenr)
  wincmd p
  " call vimfiler#mappings#do_action(a:method, linenr)
  call context.execute()
  unlet context
endfunction

function! s:vimfiler_smart_tree_l(method, ...)
  let file = vimfiler#get_file()
  if empty(file) 
    if (a:0 > 0 && a:1 == 1)
      exe 'normal' "\<Plug>(vimfiler_smart_h)"
    endif
    return
  endif
  let path = file.action__path
  if file.vimfiler__is_directory
    if (a:0 > 0 && a:1 == 2)
      exe 'normal' "\<Plug>(vimfiler_smart_l)"
    else
      exe 'normal' "\<Plug>(vimfiler_expand_tree)"
    endif
    normal! ^
    return
  endif
  call s:vimfiler_tree_edit(a:method)
endfunction
function! s:vimfiler_tree_tabopen()
  let bnr = bufnr('%')
  let linenr = line('.')
  let context = s:vimfiler_create_action_context('tabopen', linenr)
  call context.execute()
  unlet context
  silent! exe printf('vsplit +wincmd\ H\|wincmd\ l #%d', bnr)
endfunction

let s:vimfiler_context = {}
function! s:vimfiler_context.new(...)
  let dict = get(a:000, 0, {})
  return extend(dict, self)
endfunction

function! s:vimfiler_context.execute()
  call unite#mappings#do_action(self.action, self.files, {
        \ 'vimfiler__current_directory' : self.current_dir,
        \ })
endfunction

function! s:vimfiler_create_action_context(action, ...)
  let cursor_linenr = get(a:000, 0, line('.'))
  let vimfiler = vimfiler#get_current_vimfiler()
  let marked_files = vimfiler#get_marked_files()
  if empty(marked_files)
    let marked_files = [ vimfiler#get_file(cursor_linenr) ]
  endif

  let context = s:vimfiler_context.new({
        \ 'action' : a:action,
        \ 'files' : marked_files,
        \ 'current_dir' : vimfiler.current_dir,
        \ })
  return context
endfunction

function! s:vimfiler_my_settings()
  " vimfilerで開く
  nnoremap <silent> <buffer> <expr> <C-g> vimfiler#do_action('tabvimfiler')
  inoremap <silent> <buffer> <expr> <C-g> vimfiler#do_action('tabvimfiler')
  " vimshellで開く
  nnoremap <silent> <buffer> <expr> <C-f> vimfiler#do_action('tabvimshell')
  inoremap <silent> <buffer> <expr> <C-f> vimfiler#do_action('tabvimshell')
  if exists('b:vimfiler')
    if exists('b:vimfiler.context') && b:vimfiler.context.profile_name == 'ftree'
      nnoremap <silent><buffer> e :call <SID>vimfiler_tree_edit('open')<CR>
      nnoremap <silent><buffer> E :call <SID>vimfiler_tree_tabopen()<CR>
      nnoremap <silent><buffer> l :call <SID>vimfiler_smart_tree_l('')<CR>
      nnoremap <silent><buffer> <LeftMouse> <Esc>:set eventignore=all<CR>:call <SID>noscrolloff_leftmouse()<CR>:call <SID>vimfiler_smart_tree_l('', 1)<CR>:set eventignore=<CR>
      nnoremap <silent><buffer> <2-LeftMouse> <Esc>:set eventignore=all<CR>:call <SID>noscrolloff_leftmouse()<CR>::set eventignore=<CR>:call <SID>vimfiler_smart_tree_l('open', 2)<CR>
      nmap <buffer> L <Plug>(vimfiler_smart_l)
      nnoremap <silent><buffer> h :call <SID>vimfiler_smart_tree_h()<CR>
    endif
  endif
endfunction



autocmd FileType vimfiler call s:vimfiler_my_settings()

map <silent> <Leader>fi ::VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>
map <silent> <Leader>ff ::VimFilerBufferDir<CR>
" }}}
" grep.vim {{{

" 検索外のディレクトリ、ファイルパターン
let Grep_Skip_Dirs = '.svn .git .hg'
let Grep_Skip_Files = '*.bak *~'
" }}}
" vim-rooter {{{

map <silent> <unique> <Leader>vcd <Plug>RooterChangeToRootDirectory
let g:rooter_patterns = ['.git', 'package.json', 'Rakefile', 'Gemfile', 'Gruntfile.js', 'codekit-config.json', 'config.rb']
let g:rooter_change_directory_for_non_project_files = 1
" }}}

"
" programming
"
" quickrun.vim {{{

let g:quickrun_config = {}
let g:quickrun_config._ = {
  \ 'runner' : 'vimproc',
  \ "runner/vimproc/updatetime" : 60,
  \ 'vsplit': '',
  \ "outputter/error/error" : "quickfix",
  \ "outputter/error/success" : "buffer",
  \ 'outputter/buffer/close_on_empty' : 1,
  \ "hook/shabadoubi_touch_henshin/enable" : 1,
  \ "hook/shabadoubi_touch_henshin/wait" : 20
  \}
let g:quickrun_config['coffee/compile'] = {
  \ 'command': 'coffee',
  \ 'cmdopt': '-cb',
  \ 'exec': '%c %o %s'
  \ }
let g:quickrun_config['markdown'] = {
  \ 'outputter': 'browser'
  \ }
" phpunit
let g:quickrun_config['phpunit'] = {
  \ 'command': "phpunit",
  \ 'cmdopt': "",
  \ 'exec': '%c %o %s',
  \ 'outputter': 'phpunit',
  \ 'outputter/buffer/split': 'vertical 35',
  \ 'outputter/phpunit/height': 3
  \}
let g:quickrun_config['swift'] = {
  \ 'command': '/Applications/Xcode6-Beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift',
  \ 'cmdopt': '-i',
  \ 'exec': '%c %o %s'
  \ }
let g:quickrun_config['ruby/system'] = {
  \ 'command': 'ruby',
  \ 'cmdopt': '',
  \ 'exec': '%c %o %s'
  \ }
let g:quickrun_config['ruby/bundle'] = {
  \ 'command': 'ruby',
  \ 'cmdopt': 'bundle exec',
  \ 'exec': '%o %c %s'
  \ }
let g:quickrun_config['rust/rustc'] = {
  \ 'command': 'rustc',
  \ 'cmdopt': '',
  \ 'exec': '%c %o %s'
  \ }
let g:quickrun_config['rust/cargo'] = {
  \ 'command': 'cargo',
  \ 'cmdopt': 'run',
  \ 'exec': '%c %o'
  \ }
nnoremap <Leader>rr :QuickRun<CR>
" <C-c> で実行を強制終了させる
nnoremap <expr><silent> <C-c> quickrun#is_running() ?  quickrun#sweep_sessions() : "\<C-c>"

" quickfix のエラー箇所を波線でハイライト
execute "highlight qf_error_ucurl gui=undercurl guisp=Red"
let g:hier_highlight_group_qf  = "qf_error_ucurl"
"}}}
" errormarker.vim {{{

" disable default shortcut mapping and re-define to <Leader>ec
let g:errormarker_disablemappings = 1
nmap <silent> <Leader>ec :ErrorAtCursor<CR>
"gccのErrorとWarningを見分ける
let &errorformat="%f:%l:%c: %t%*[^:]:%m,%f:%l: %t%*[^:]:%m," . &errorformat 
" }}}
" Syntastic {{{

" エラー行をsignで表示する
let g:syntastic_enable_signs = 1
nnoremap <Space>e :Errors<CR>

" }}}

"
" utilities
"
" vimshell {{{

let g:vimshell_user_prompt = 'fnamemodify(getcwd(), ":~")'
" let g:vimshell_right_prompt = 'vimshell#vcs#info("(%s)-[%b]", "(%s)-[%b|%a]")'
let g:vimshell_enable_smart_case = 1

noremap <Leader>fs :VimShellBufferDir<CR>
noremap <Leader>s :VimShellPop<CR>
nmap <Leader>pry :VimShellInteractive pry<CR>
" }}}
" taglist.vim {{{
let Tlist_Show_One_File = 1               " 現在編集中のソースのタグしか表示しない
let Tlist_Use_Right_Window = 1            " 右側でtaglistのウィンドーを表示
let Tlist_Auto_Update = 1
let Tlist_WinWidth = 30
map <silent> <Leader>tl :TlistToggle<CR>
" }}}
" alpaca_tags {{{
let g:alpaca_update_tags_config = {
      \ '_' : '-R --sort=yes --languages=+Ruby --languages=-css,scss,html',
      \ 'js' : '--languages=+js',
      \ 'ruby': '--languages=+Ruby',
      \ }
let g:alpaca_tags_ctags_bin = '/opt/boxen/homebrew/bin/ctags'

augroup AlpacaTags
  autocmd!
  if exists(':Tags')
    autocmd BufWritePost * TagsUpdate ruby
    autocmd BufWritePost Gemfile TagsBundle
    autocmd BufEnter * TagsSet
  endif
augroup END
" }}}
" open-blowser.vim {{{

" カーソル下のURLをブラウザで開く
nmap <Leader>ob <Plug>(openbrowser-open)
vmap <Leader>ob <Plug>(openbrowser-open)
" カーソル下のキーワードをググる
nmap <Leader>ok :<C-u>OpenBrowserSearch<Space><C-r><C-w><CR>
vmap <Leader>ok <Plug>(openbrowser-search)
" }}}
" text-object {{{
omap iF <Plug>(textobj-function-i)
omap aF <Plug>(textobj-function-a)
vmap iF <Plug>(textobj-function-i)
vmap aF <Plug>(textobj-function-a)
" }}}

"
" language
"
" dash {{{
nnoremap <Leader>d :<C-u>Dash<CR>
"}}}
" ruby {{{

call smartinput_endwise#define_default_rules()

" }}}
" rails {{{

let g:rails_default_file='config/database.yml'
let g:rails_level = 4
let g:rails_mappings=1
let g:rails_modelines=0
" let g:rails_some_option = 1
" let g:rails_statusline = 1
" let g:rails_subversion=0
" let g:rails_syntax = 1
" let g:rails_url='http://localhost:3000'
" let g:rails_ctags_arguments='--languages=-javascript'
" let g:rails_ctags_arguments = ''

autocmd User Rails call s:do_rails_autocmd()
autocmd User Rails.view*                 NeoSnippetSource ~/.vim/snippets/ruby.rails.view.snip
autocmd User Rails.model                 NeoSnippetSource ~/.vim/snippets/ruby.rails.model.snip
autocmd User Rails.controller*           NeoSnippetSource ~/.vim/snippets/ruby.rails.controller.snip
autocmd User Rails/config/routes.rb      NeoSnippetSource ~/.vim/snippets/ruby.rails.route.snip
autocmd User Rails/config/environment.rb NeoSnippetSource ~/.vim/snippets/ruby.rails.environment.snip
autocmd User Rails/config/routes.rb      NeoSnippetSource ~/.vim/snippets/ruby.rails.route.snip
autocmd User Rails.spec.model            NeoSnippetSource ~/.vim/snippets/ruby.rspec.model.snip
autocmd User Rails.spec.controller       NeoSnippetSource ~/.vim/snippets/ruby.rspec.controller.snip
autocmd User Rails.spec.helper           NeoSnippetSource ~/.vim/snippets/ruby.rspec.helper.snip
autocmd User Rails.spec.feature          NeoSnippetSource ~/.vim/snippets/ruby.capybara.snip
autocmd User Rails.spec.routing          NeoSnippetSource ~/.vim/snippets/ruby.rspec.routing.snip
autocmd User Rails.fixtures.replacement  NeoSnippetSource ~/.vim/snippets/ruby.factory_girl.snip
autocmd User Rails/db/migrate/*          NeoSnippetSource ~/.vim/snippets/ruby.rails.migrate.snip

"autocmd User Rails/spec/models/*等を可能に
function! s:gsub(string, pattern, replacement)
  return substitute(a:string, '\v\C'.a:pattern, a:replacement, 'g')
endfunction

function! s:do_rails_autocmd()
if !exists("b:rails_root")
return
endif
 
let buf = rails#buffer()
let type = "-" . buf.type_name()
let path = '/' . buf.name()
if path =~ '[ !#$%\,]'
let path = ''
endif
 
if type != '-'
execute "silent doautocmd User Rails" . s:gsub(type, '-', '.')
endif
 
if path != ''
execute "silent doautocmd User Rails" . path
endif
endfunction

autocmd BufWinEnter,BufNewFile Gemfile set filetype=Gemfile syntax=ruby
nnoremap <Space>a :<C-u>A<CR>

" }}}
" php {{{
let g:neocomplete_php_locale = 'ja'
" }}}
" phpcomplete-extended {{{
autocmd  FileType  php setlocal omnifunc=phpcomplete_extended#CompletePHP
let g:phpcomplete_index_composer_command = 'composer'
" }}}
" laravel {{{
noremap <Leader>art :VimShellInteractive php artisan 
" }}}
" vim2hs {{{
let g:haskell_conceal = 0
" }}}
" unite-haskellimport {{{
nnoremap <silent> [unite]hi :<C-u>Unite haskellimport<CR>
" }}}
" coffee {{{
au BufRead,BufNewFile,BufReadPre *.coffee   set filetype=coffee
" 保存時にコンパイル
" autocmd BufWritePost *.coffee silent CoffeeMake! -cb | cwindow | redraw!
" }}}
" jsx {{{
au BufRead,BufNewFile,BufReadPre *.jsx   set filetype=jsx
" }}}
" powerline {{{
set laststatus=2
let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'mode_map': { 'c': 'NORMAL' },
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
      \ },
      \ 'component_function': {
      \   'modified': 'MyModified',
      \   'readonly': 'MyReadonly',
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \ },
      \ 'separator': { 'left': '', 'right': '' },
      \ 'subseparator': { 'left': '', 'right': '' }
      \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '' : ''
endfunction

function! MyFilename()
  return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() : 
        \  &ft == 'unite' ? unite#get_status_string() : 
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists("*fugitive#head")
    let _ = fugitive#head()
    return strlen(_) ? ' '._ : ''
  endif
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction
" }}}
" python {{{
let g:jedi#auto_initialization = 0
let g:jedi#auto_vim_configuration = 0
autocmd FileType python setlocal completeopt-=preview

let g:jedi#rename_command = ""
let g:jedi#documentation_command = ""
" }}}

" vim: foldmethod=marker
